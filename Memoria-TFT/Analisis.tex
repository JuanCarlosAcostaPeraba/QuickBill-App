%----------------------------------------------------------
% Capítulo 2 – Análisis
%----------------------------------------------------------

%----------------------------------------------------------
\section{Problema}
%----------------------------------------------------------

\begin{large}

El día a día de muchas pymes y autónomos sigue un recorrido fragmentado, combinando plantillas en hojas de cálculo, correos electrónicos y archivado físico. Esta fragmentación obliga a reintroducir datos manualmente en varias aplicaciones, aumentando el riesgo de errores humanos e inconsistencias, dificultando la obtención de información financiera fiable y generando retrasos en los cobros y pagos. Además, la falta de conectividad estable limita gravemente la movilidad, impidiendo emitir o consultar facturas en tiempo real, provocando que la información quede rápidamente obsoleta.

A esto se suman las exigencias normativas recientes, como la Ley 18/2022, que obliga a las empresas a emitir factura electrónica en todas sus transacciones comerciales, mantener registros íntegros y garantizar la autenticidad de cada documento. Cumplir con estos requisitos con herramientas tradicionales implica una inversión considerable en nuevas soluciones, formación del personal y rediseño de procesos internos, afectando negativamente la productividad, la competitividad y el potencial de crecimiento de los negocios.

\end{large}

%----------------------------------------------------------
\section{Solución}
%----------------------------------------------------------

\begin{large}

Se propone una plataforma de facturación basada en aplicaciones móviles nativas para iOS y Android y un portal web administrativo. Todas las versiones se conectan a Firestore, lo que garantiza la consistencia de los datos. Firebase actúa como backend sin servidor, reduciendo la carga de mantenimiento y permitiendo un escalado automático según el uso.

Las apps móviles siguen un modelo \textit{offline-first}: cuando no hay conexión, los datos se almacenan localmente de forma segura y se sincronizan con Firestore tan pronto se restablece la red. Así, se puede seguir trabajando sin interrupciones y los posibles conflictos se resuelven automáticamente mediante marcas de tiempo.

Se plantea utilizar Cloud Functions para generar los PDF de las facturas, aplicar numeración secuencial y almacenar los archivos en Cloud Storage. La seguridad está cubiera con reglas de Firestore, autenticación y cifrado, cumpliendo con el \gls{rgpd} y dejando registro de auditoría para cada operación sensible.

El portal web, construido con \gls{astro} y alojado en Vercel, muestra en tiempo real indicadores clave (ingresos cobrados, importes pendientes, ratio de morosidad). Gracias a la suscripción en tiempo real a Firestore y al enfoque de generar HTML estático en el servidor y habilitar la hidratación únicamente en los componentes que lo requieren, la interfaz permanece ligera, accesible y adaptable a distintos dispositivos. En conjunto, esta solución unifica el flujo de trabajo, elimina la fragmentación de herramientas y permite facturar desde cualquier lugar, reduciendo costes operativos y minimizando errores.

\end{large}

%----------------------------------------------------------
\section{Metodología}
%----------------------------------------------------------

\begin{large}

Para desarrollar la plataforma seguimos un enfoque ágil iterativo basado en Kanban y Scrum. Cada tarea se crea y prioriza en GitHub Projects, limitando el trabajo en curso para enfocarnos en entregas parciales y ajustando el alcance según sea necesario. Tras una sesión inicial de planificación (donde definimos requisitos y criterios básicos), dividimos el proyecto en cinco ciclos, y cada ciclo consta de cuatro fases:

\begin{itemize}
  \item \textbf{Análisis:} Detallamos funcionalidades y criterios de aceptación para cada incremento.
  \item \textbf{Diseño:} Definimos la arquitectura de datos y creamos prototipos de interfaz en Figma.
  \item \textbf{Implementación:} Desarrollamos la app para iOS y Android, escribimos las funciones de backend y construimos el portal web.  
  \item \textbf{Pruebas:} Realizamos pruebas manuales en dispositivos emulados para verificar que cada función cumple los requisitos.
\end{itemize}

Al completar los cinco ciclos, dedicamos tiempo a redactar la documentación final: manuales de usuario, guía de despliegue y la propia memoria técnica. Durante esta última fase, generamos capturas y métricas que respalden los resultados.

Con este esquema iterativo, avanzamos de forma progresiva, mantuvimos la calidad en cada entrega y nos permitió incorporar mejoras o ajustes según surgían nuevos retos.

\end{large}

%----------------------------------------------------------
\section{Organización del proyecto}
%----------------------------------------------------------

\begin{large}

La plataforma se ha organizado en dos componentes principales, correspondientes a los clientes nativos y al portal web:

\end{large}

\subsection*{App iOS (\textit{Swift})}

\begin{large}

El código de la aplicación iOS sigue el patrón Model–View–ViewModel (MVVM) para separar lógicamente la interfaz de usuario de la capa de datos y negocio. 
\begin{itemize}
  \item \textbf{Modelo (Model):} Contiene las estructuras que representan entidades como Empresas, Clientes y Facturas. Estas estructuras definen los campos que se almacenan en Firestore (por ejemplo, fecha de emisión, importe, estado, etc.) y métodos para convertir documentos de Firestore a objetos Swift.
  \item \textbf{Vista (View):} Con SwiftUI se crearon vistas reutilizables para cada pantalla principal: lista de facturas, detalle de factura, formulario de creación/edición y ajustes. Cada vista se conecta a su ViewModel mediante propiedades marcadas con \texttt{@ObservedObject} o \texttt{@StateObject}.
  \item \textbf{ViewModel:} Cada pantalla tiene un ViewModel que agrupa la lógica de negocio y la interacción con Firebase. Los ViewModels se encargan de:
    \begin{itemize}
      \item Recuperar y observar los cambios en documentos de Firestore.
      \item Validar y formatear datos antes de mostrarlos en pantalla.
      \item Enviar nuevas facturas a Firestore, gestionar el estado (Paid/Pending) y calcular totales.
      \item Generar el PDF de la factura y guardarlo localmente, empleando el ID único de Firestore para numeración.
    \end{itemize}
  \item \textbf{Servicios de Firebase:}  
    \begin{itemize}
      \item \textit{Firestore:} Actúa como base de datos de documentos. Cada colección almacena objetos con la información necesaria.
      \item \textit{Authentication:} Gestiona el inicio de sesión con correo/contraseña, manteniendo sesiones y seguridad.
    \end{itemize}
\end{itemize}

\end{large}

\subsection*{App Android (Kotlin)}

\begin{large}

La versión para Android estaba prevista en Kotlin siguiendo una arquitectura similar (MVVM), pero debido a limitaciones de tiempo no llegó a completarse. La carpeta \texttt{android/} contiene el esqueleto del proyecto (configuración de Gradle, dependencias de Firebase, diseño de pantallas básicas), pero las funciones principales (CRUD de facturas, generación de PDF, lógica de sincronización) quedaron pendientes y se documentan como trabajo futuro.

\end{large}

\subsection*{Portal Web}

\begin{large}

El portal web se desarrolló con el framework Astro y estilos en TailwindCSS. La estructura principal del código es:
\begin{itemize}
  \item \textbf{Páginas estáticas (`/src/pages`):}  
    \begin{itemize}
      \item \texttt{index.astro}: Página de inicio que contiene la gráfica donde se muestra el total de los pagado y de lo que queda pendiente de pago mensualmente.
      \item \texttt{login.astro}: Página para que los usuarios, previamente registrados desde la aplicación móvil, puedan acceder con sus credenciales.
    \end{itemize}
  \item \textbf{Componentes (`/src/components`):}  
    \begin{itemize}
      \item \texttt{ButtonToScrollToTop.astro}: Componente que renderiza un botón en la esquina inferior derecha de la página para volver al inicio de la página.
      \item \texttt{Header.astro}: Componente que renderiza la cabecera de la página con un enlace de la web, un menú de navegación entre las diferentes secciones y el botón de cerrar la sesión.
      \item \texttt{MoneyChart.astro}: Componente que renderiza la gráfica de barras usando \textit{lightweight-charts}.
      \item \texttt{OverdueList.astro}: Componente que renderiza el listado de los clientes que no han pagado en su tiempo (morosos), haciendo el cálculo de la cantidad total que deben.
    \end{itemize}
  \item \textbf{Servicios de Firebase (en `/src/firebase`):}  
    \begin{itemize}
      \item \texttt{config.ts}: Fichero con la configuración para establecer la conexión con firebase.
      \item \texttt{firebase.ts}: Inicializa la instancia de Firebase y exporta funciones para autenticar y leer cualquier dato de Firestore.
    \end{itemize}
  \item \textbf{Despliegue:}  
    \begin{itemize}
      \item El portal web se publica en Vercel, con integración continua vía GitHub Actions. Cada merge a `main` dispara un despliegue automático.
    \end{itemize}
\end{itemize}

\end{large}

\subsection*{Modelo de datos en Firestore}

\begin{large}

\begin{lstlisting}[language={},basicstyle=\ttfamily\small]
/businesses/{businessId}
    |-- name
    |-- tagline (nullable)
    |-- address
    |-- city
    |-- country
    |-- postcode
    |-- taxId (CIF in Spain, VAT in the UK, EIN in the USA, etc.)
    |-- email
    |-- phone
    |-- createdAt
    |-- subscriptionPlan: "free" | "premium"
    |-- storageLimit: "1 month" | "unlimited"
    |
    |-- employees/{employeeId}
    |        |-- userId (linked to Firebase Auth)
    |        |-- name
    |        |-- email (linked to Firebase Auth)
    |        |-- phone
    |        |-- role: "admin" | "employee" (linked to Firebase Auth)
    |        |-- joinedAt
    |
    |-- clients/{clientId}
    |        |-- userClientId (linked to Firebase Auth) ??
    |        |-- companyName
    |        |-- clientName
    |        |-- address
    |        |-- city
    |        |-- country
    |        |-- postcode
    |        |-- email (linked to Firebase Auth)
    |        |-- phone
    |        |-- createdAt
    |
    |-- invoices/{invoiceId}
    |        |-- issuedAt
    |        |-- dueDate
    |        |-- status: "Paid" | "Pending" | "Overdue"
    |        |-- subtotal
    |        |-- taxTotal
    |        |-- discounts
    |        |-- totalAmount
    |        |-- currency
    |        |-- clientId
    |        |-- employeeId
    |        |-- pdfURL (Cloudflare)
    |        |-- deleteAfter (Free plan: issuedAt + 1 month,
                                Premium plan: unlimited)
    |        |-- productsStack/{productStackId}
    |                          |-- productId
    |                          |-- supplyDate
    |                          |-- quantity
    |                          |-- amount
    |                          |-- taxRate
    |                          |-- taxNet
    |
    |-- products/{productId}
    |        |-- description
    |        |-- unitPrice
\end{lstlisting}

\begin{description}[leftmargin=3cm, style=nextline]
  \item[\texttt{businesses/\{businessId\}}] Documento principal que contiene datos generales de la empresa (nombre, contactos, identificación fiscal, suscripción y límites de almacenamiento) y agrupa subcolecciones.
  \item[\texttt{businesses/\{businessId\}/employees/\{employeeId\}}] Empleados de la empresa, con referencia a Firebase Auth, datos de contacto y rol.
  \item[\texttt{businesses/\{businessId\}/clients/\{clientId\}}] Clientes asociados a la empresa, con datos de contacto y posible vinculación a Firebase Auth.
  \item[\texttt{businesses/\{businessId\}/invoices/\{invoiceId\}}] Facturas emitidas por la empresa, con fechas, estado, importes y subcolección \texttt{productsStack} para desglosar cada línea de producto (ID de producto, cantidad, impuesto, etc.).
  \item[\texttt{businesses/\{businessId\}/products/\{productId\}}] Productos que la empresa ofrece, con descripción y precio unitario.
\end{description}

Esta organización centraliza la lógica de datos y asegura coherencia en todos los clientes, facilitando la mantenibilidad y escalabilidad del sistema.

\end{large}

%----------------------------------------------------------
\section{Herramientas}
%----------------------------------------------------------

\begin{large}

Esta sección describe las tecnologías empleadas en cada capa de la plataforma y las razones de su elección.

\subsection*{iOS}

Las aplicaciones para iPhone se implementan en \textbf{Swift}, un lenguaje moderno creado por Apple que prioriza la seguridad mediante tipado fuerte y gestión automática de memoria, y el rendimiento gracias a la optimización de sus compiladores \gls{llvm} \cite{swift_lang2025}.

El entorno de desarrollo es \textbf{Xcode} 16.3. Este IDE integra editor, depurador, simuladores de dispositivos y marcos de pruebas unitarias y de interfaz. Herramientas como Instruments permiten perfilar CPU, memoria y consumo energético, lo que facilita detectar cuellos de botella y mantener la fluidez de la experiencia. Con esta combinación el código se compila a binarios nativos y se alinea con las directrices de accesibilidad de iOS sin recurrir a SDK externos \cite{xcode16_3}.

\subsection*{Android}

La versión para Android se escribe en \textbf{Kotlin}, un lenguaje conciso y expresivo que incorpora nulabilidad segura y corrutinas para la programación asíncrona \cite{kotlin_lang2025}.

El desarrollo se realiza en \textbf{Android Studio} 2024.3.2 (Meerkat Feature Drop). Esta versión incorpora emuladores con perfiles personalizables, inspector de bases de datos y analizador de rendimiento en tiempo real, además de plantillas que agilizan la integración con bibliotecas Jetpack \cite{as2024_3_2}. La combinación de Kotlin con Android Studio reduce la verbosidad, mejora la legibilidad y disminuye la probabilidad de errores típicos de Java.

\subsection*{Web}

El portal administrativo se construye con \textbf{Astro}. Este framework genera HTML estático en la compilación y aplica hidratación parcial solo a los componentes que requieren interactividad, de modo que la carga inicial resulta ligera y accesible \cite{astro_docs2025}.

Para la gestión de dependencias se utiliza \textbf{pnpm}, un gestor que comparte una caché global y evita duplicados en \textit{node\_modules}, lo que acelera las instalaciones \cite{pnpm_docs2025}. El despliegue se realiza en Firebase Hosting y la lógica de servidor reside en Cloud Functions escritas en TypeScript, lo que proporciona escalado automático sin necesidad de administrar infraestructura.

\subsection*{Servicios en la nube}

La capa de backend y servicios gestionados se apoya en \textbf{Firebase}. Este conjunto de productos de Google aporta una base de datos NoSQL en tiempo real (Firestore), reglas de seguridad personalizables, autenticación multifactor y almacenamiento de archivos en Cloud Storage \cite{firebase_docs2025}. La lógica de servidor se desarrolla con Cloud Functions escritas en TypeScript, mientras que Firebase Hosting proporciona un despliegue estático con certificados TLS automáticos. Gracias a sus capacidades de escalado bajo demanda, la plataforma puede crecer sin intervención administrativa y sin inversiones iniciales en infraestructura.

\subsection*{Control de versiones}

El control de cambios se lleva a cabo con \textbf{Git}, sistema distribuido que mantiene un historial completo y permite revertir versiones con precisión \cite{git_book2023}. El repositorio se aloja en \textbf{GitHub}, plataforma que ofrece \textit{pull requests}, revisiones entre pares y flujos de integración y entrega continuas mediante GitHub Actions \cite{github_docs2025}. Cada confirmación ejecuta linters, pruebas y despliegues a canales de previsualización, lo que garantiza calidad continua y retroalimentación temprana.

\end{large}
