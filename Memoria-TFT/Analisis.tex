%----------------------------------------------------------
% Capítulo 2 – Análisis
%----------------------------------------------------------

%----------------------------------------------------------
\section{Problema}
%----------------------------------------------------------

\begin{large}

El día a día de muchas pymes y autónomos sigue un recorrido fragmentado, combinando plantillas en hojas de cálculo, correos electrónicos y archivado físico. Esta fragmentación obliga a reintroducir datos manualmente en varias aplicaciones, aumentando el riesgo de errores humanos e inconsistencias, dificultando la obtención de información financiera fiable y generando retrasos en los cobros y pagos. Además, la falta de conectividad estable limita gravemente la movilidad, impidiendo emitir o consultar facturas en tiempo real, provocando que la información quede rápidamente obsoleta.

A esto se suman las exigencias normativas recientes, como la Ley 18/2022, que obliga a las empresas a emitir factura electrónica en todas sus transacciones comerciales, mantener registros íntegros y garantizar la autenticidad de cada documento. Cumplir con estos requisitos con herramientas tradicionales implica una inversión considerable en nuevas soluciones, formación del personal y rediseño de procesos internos, afectando negativamente la productividad, la competitividad y el potencial de crecimiento de los negocios.

\end{large}

%----------------------------------------------------------
\section{Solución}
%----------------------------------------------------------

\begin{large}

Se propone una plataforma de facturación basada en aplicaciones móviles nativas para iOS y Android y un portal web administrativo. Todas las versiones se conectan a Firestore, lo que garantiza la consistencia de los datos. Firebase actúa como backend sin servidor, reduciendo la carga de mantenimiento y permitiendo un escalado automático según el uso.

Las apps móviles siguen un modelo \textit{offline-first}: cuando no hay conexión, los datos se almacenan localmente de forma segura y se sincronizan con Firestore tan pronto se restablece la red. Así, se puede seguir trabajando sin interrupciones y los posibles conflictos se resuelven automáticamente mediante marcas de tiempo.

Se plantea utilizar Cloud Functions para generar los PDF de las facturas, aplicar numeración secuencial y almacenar los archivos en Cloud Storage. La seguridad está cubiera con reglas de Firestore, autenticación y cifrado, cumpliendo con el \gls{rgpd} y dejando registro de auditoría para cada operación sensible.

El portal web, construido con \gls{astro} y alojado en Vercel, muestra en tiempo real indicadores clave (ingresos cobrados, importes pendientes, ratio de morosidad). Gracias a la suscripción en tiempo real a Firestore y al enfoque de generar HTML estático en el servidor y habilitar la hidratación únicamente en los componentes que lo requieren, la interfaz permanece ligera, accesible y adaptable a distintos dispositivos. En conjunto, esta solución unifica el flujo de trabajo, elimina la fragmentación de herramientas y permite facturar desde cualquier lugar, reduciendo costes operativos y minimizando errores.

\end{large}

%----------------------------------------------------------
\section{Metodología}
%----------------------------------------------------------

\begin{large}

Para desarrollar la plataforma seguimos un enfoque ágil iterativo basado en Kanban y Scrum. Cada tarea se crea y prioriza en GitHub Projects, limitando el trabajo en curso para enfocarnos en entregas parciales y ajustando el alcance según sea necesario. Tras una sesión inicial de planificación (donde definimos requisitos y criterios básicos), dividimos el proyecto en cinco ciclos, y cada ciclo consta de cuatro fases:

\begin{itemize}
  \item \textbf{Análisis:} Detallamos funcionalidades y criterios de aceptación para cada incremento.
  \item \textbf{Diseño:} Definimos la arquitectura de datos y creamos prototipos de interfaz en Figma.
  \item \textbf{Implementación:} Desarrollamos la app para iOS y Android, escribimos las funciones de backend y construimos el portal web.  
  \item \textbf{Pruebas:} Realizamos pruebas manuales en dispositivos emulados para verificar que cada función cumple los requisitos.
\end{itemize}

Al completar los cinco ciclos, dedicamos tiempo a redactar la documentación final: manuales de usuario, guía de despliegue y la propia memoria técnica. Durante esta última fase, generamos capturas y métricas que respalden los resultados.

Con este esquema iterativo, avanzamos de forma progresiva, mantuvimos la calidad en cada entrega y nos permitió incorporar mejoras o ajustes según surgían nuevos retos.

\end{large}

%----------------------------------------------------------
\section{Organización del proyecto}
%----------------------------------------------------------

\begin{large}

La plataforma se ha organizado en dos componentes principales, correspondientes a los clientes nativos y al portal web:

\end{large}

\subsection{App iOS (\textit{Swift})}

\begin{large}

El código de la aplicación iOS sigue el patrón Model–View–ViewModel (MVVM) para separar lógicamente la interfaz de usuario de la capa de datos y negocio. 
\begin{itemize}
  \item \textbf{Modelo (Model):} Contiene las estructuras que representan entidades como Empresas, Clientes y Facturas. Estas estructuras definen los campos que se almacenan en Firestore (por ejemplo, fecha de emisión, importe, estado, etc.) y métodos para convertir documentos de Firestore a objetos Swift.
  \item \textbf{Vista (View):} Con SwiftUI se crearon vistas reutilizables para cada pantalla principal: lista de facturas, detalle de factura, formulario de creación/edición y ajustes. Cada vista se conecta a su ViewModel mediante propiedades marcadas con \texttt{@ObservedObject} o \texttt{@StateObject}.
  \item \textbf{ViewModel:} Cada pantalla tiene un ViewModel que agrupa la lógica de negocio y la interacción con Firebase. Los ViewModels se encargan de:
    \begin{itemize}
      \item Recuperar y observar los cambios en documentos de Firestore.
      \item Validar y formatear datos antes de mostrarlos en pantalla.
      \item Enviar nuevas facturas a Firestore, gestionar el estado (Paid/Pending) y calcular totales.
      \item Generar el PDF de la factura y guardarlo localmente, empleando el ID único de Firestore para numeración.
    \end{itemize}
  \item \textbf{Servicios de Firebase:}  
    \begin{itemize}
      \item \textit{Firestore:} Actúa como base de datos de documentos. Cada colección almacena objetos con la información necesaria.
      \item \textit{Authentication:} Gestiona el inicio de sesión con correo/contraseña, manteniendo sesiones y seguridad.
    \end{itemize}
\end{itemize}

\end{large}

\subsection{App Android (Kotlin)}

\begin{large}

La versión para Android estaba prevista en Kotlin siguiendo una arquitectura similar (MVVM), pero debido a limitaciones de tiempo no llegó a completarse. La carpeta \texttt{android/} contiene el esqueleto del proyecto (configuración de Gradle, dependencias de Firebase, diseño de pantallas básicas), pero las funciones principales (CRUD de facturas, generación de PDF, lógica de sincronización) quedaron pendientes y se documentan como trabajo futuro.

\end{large}

\subsection{Portal Web (Astro)}

\begin{large}

El portal web se desarrolló con el framework Astro y estilos en TailwindCSS. La estructura principal del código es:
\begin{itemize}
  \item \textbf{Páginas estáticas (`/src/pages`):}  
    \begin{itemize}
      \item \texttt{index.astro}: Página de inicio que contiene la gráfica donde se muestra el total de los pagado y de lo que queda pendiente de pago mensualmente.
      \item \texttt{login.astro}: Página para que los usuarios, previamente registrados desde la aplicación móvil, puedan acceder con sus credenciales.
    \end{itemize}
  \item \textbf{Componentes (`/src/components`):}  
    \begin{itemize}
      \item \texttt{ButtonToScrollToTop.astro}: Componente que renderiza un botón en la esquina inferior derecha de la página para volver al inicio de la página.
      \item \texttt{Header.astro}: Componente que renderiza la cabecera de la página con un enlace de la web, un menú de navegación entre las diferentes secciones y el botón de cerrar la sesión.
      \item \texttt{MoneyChart.astro}: Componente que renderiza la gráfica de barras usando \textit{lightweight-charts}.
      \item \texttt{OverdueList.astro}: Componente que renderiza el listado de los clientes que no han pagado en su tiempo (morosos), haciendo el cálculo de la cantidad total que deben.
    \end{itemize}
  \item \textbf{Servicios de Firebase (en `/src/firebase`):}  
    \begin{itemize}
      \item \texttt{config.ts}: Fichero con la configuración para establecer la conexión con firebase.
      \item \texttt{firebase.ts}: Inicializa la instancia de Firebase y exporta funciones para autenticar y leer cualquier dato de Firestore.
    \end{itemize}
  \item \textbf{Despliegue:}  
    \begin{itemize}
      \item El portal web se publica en Vercel, con integración continua vía GitHub Actions. Cada merge a `main` dispara un despliegue automático.
    \end{itemize}
\end{itemize}

\end{large}

\subsection{Modelo de datos en Firestore}

\begin{large}

\begin{lstlisting}[language={},basicstyle=\ttfamily\small]
/businesses/{businessId}
    |-- name
    |-- tagline (nullable)
    |-- address
    |-- city
    |-- country
    |-- postcode
    |-- taxId (CIF in Spain, VAT in the UK, EIN in the USA, etc.)
    |-- email
    |-- phone
    |-- createdAt
    |-- subscriptionPlan: "free" | "premium"
    |-- storageLimit: "1 month" | "unlimited"
    |
    |-- employees/{employeeId}
    |        |-- userId (linked to Firebase Auth)
    |        |-- name
    |        |-- email (linked to Firebase Auth)
    |        |-- phone
    |        |-- role: "admin" | "employee" (linked to Firebase Auth)
    |        |-- joinedAt
    |
    |-- clients/{clientId}
    |        |-- userClientId (linked to Firebase Auth) ??
    |        |-- companyName
    |        |-- clientName
    |        |-- address
    |        |-- city
    |        |-- country
    |        |-- postcode
    |        |-- email (linked to Firebase Auth)
    |        |-- phone
    |        |-- createdAt
    |
    |-- invoices/{invoiceId}
    |        |-- issuedAt
    |        |-- dueDate
    |        |-- status: "Paid" | "Pending" | "Overdue"
    |        |-- subtotal
    |        |-- taxTotal
    |        |-- discounts
    |        |-- totalAmount
    |        |-- currency
    |        |-- clientId
    |        |-- employeeId
    |        |-- pdfURL (Cloudflare)
    |        |-- deleteAfter (Free plan: issuedAt + 1 month,
                                Premium plan: unlimited)
    |        |-- productsStack/{productStackId}
    |                          |-- productId
    |                          |-- supplyDate
    |                          |-- quantity
    |                          |-- amount
    |                          |-- taxRate
    |                          |-- taxNet
    |
    |-- products/{productId}
    |        |-- description
    |        |-- unitPrice
\end{lstlisting}

\begin{description}[leftmargin=3cm, style=nextline]
  \item[\texttt{businesses/\{businessId\}}] Documento principal que contiene datos generales de la empresa (nombre, contactos, identificación fiscal, suscripción y límites de almacenamiento) y agrupa subcolecciones.
  \item[\texttt{businesses/\{businessId\}/employees/\{employeeId\}}] Empleados de la empresa, con referencia a Firebase Auth, datos de contacto y rol.
  \item[\texttt{businesses/\{businessId\}/clients/\{clientId\}}] Clientes asociados a la empresa, con datos de contacto y posible vinculación a Firebase Auth.
  \item[\texttt{businesses/\{businessId\}/invoices/\{invoiceId\}}] Facturas emitidas por la empresa, con fechas, estado, importes y subcolección \texttt{productsStack} para desglosar cada línea de producto (ID de producto, cantidad, impuesto, etc.).
  \item[\texttt{businesses/\{businessId\}/products/\{productId\}}] Productos que la empresa ofrece, con descripción y precio unitario.
\end{description}

Esta organización centraliza la lógica de datos y asegura coherencia en todos los clientes, facilitando la mantenibilidad y escalabilidad del sistema.

\end{large}

%----------------------------------------------------------
\section{Herramientas}
%----------------------------------------------------------

\begin{large}

En este proyecto hemos elegido herramientas que permitan un flujo de trabajo ágil y tecnológico acorde al alcance de la plataforma:

\end{large}

\subsection{iOS}

\begin{large}

Para la app de iPhone se utiliza \textbf{Swift}, un lenguaje moderno que destaca por su seguridad (tipado fuerte y gestión automática de memoria) y buen rendimiento gracias a sus compiladores optimizados \cite{swift_lang2025}. El desarrollo se lleva a cabo en \textbf{Xcode} 16.3, que combina editor, depurador y simulador de dispositivos. Además, Instruments facilita perfilar CPU, memoria y consumo energético, lo que ayuda a mejorar la fluidez de la interfaz. Con SwiftUI, se construyen vistas reutilizables que interactúan con los ViewModels, separando claramente la lógica de negocio de la presentación.

\end{large}

\subsection{Android}

\begin{large}

La versión para Android se prediseñó en \textbf{Kotlin} con una arquitectura MVVM similar a la de iOS, aprovechando su sintaxis concisa, el manejo seguro de nulabilidad y las corrutinas para tareas asíncronas \cite{kotlin_lang2025}. El entorno de trabajo es \textbf{Android Studio} 2024.3.2 (Meerkat Feature Drop), que incluye emuladores configurables, herramientas para inspeccionar bases de datos y analizadores de rendimiento en tiempo real \cite{as2024_3_2}. En esta primera iteración el esqueleto del proyecto está preparado, aunque las funcionalidades principales se documentan para futuras versiones.

\end{large}

\subsection{Web}

\begin{large}

El portal administrativo se desarrolla con \textbf{Astro}, que genera HTML estático en tiempo de compilación y aplica hidratación sólo donde se necesita, lo que reduce el tamaño inicial y mejora el rendimiento \cite{astro_docs2025}. Los estilos se gestionan con \textbf{TailwindCSS}, facilitando una personalización rápida y coherente sin escribir CSS extenso. Para instalar dependencias se usa \textbf{pnpm}, que acelera el proceso al compartir una caché global y evitar duplicados \cite{pnpm_docs2025}. El sitio se despliega en \textbf{Vercel}, integrando despliegues automáticos en cada fusión a la rama principal.

\end{large}

\subsection{Servicios en la nube}

\begin{large}

Como backend se optó por \textbf{Firebase}, por su conjunto completo de servicios gestionados. \textit{Firestore} ofrece una base de datos NoSQL en tiempo real y escalable, mientras que \textit{Authentication} gestiona usuarios con correo y contraseña de forma sencilla. Aunque se planteó usar \textit{Cloud Functions} para tareas como generación de PDFs y almacenamiento, algunas de esas funciones quedaron para versiones posteriores debido a restricciones de coste \cite{firebase_docs2025}. Las reglas de Firestore garantizan seguridad tanto en lectura como en escritura, cumpliendo con el \gls{rgpd}.

Para el despliegue del portal web se eligió \textbf{Vercel}, una plataforma de hosting enfocada en sitios estáticos y Jamstack. Vercel ofrece despliegues automáticos a partir del repositorio de GitHub, gestión de dominios y certificados TLS integrados, así como funciones serverless ligeras si fueran necesarias \cite{vercel_docs2025}. Gracias a su integración continua y facilidad de configuración, el portal se publica con cada push a la rama principal, garantizando que la versión en producción esté siempre actualizada y optimizada.

\end{large}

\subsection{Control de versiones}

\begin{large}

El código se gestiona con \textbf{Git}, un sistema distribuido que conserva el historial completo y permite revertir cambios con precisión \cite{git_book2023}. El repositorio principal se aloja en \textbf{GitHub}, donde las \emph{pull requests} facilitan las revisiones entre pares. Así, cada confirmación se valida y despliega de forma controlada, asegurando una integración continua estable.

\end{large}
