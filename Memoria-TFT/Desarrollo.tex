%----------------------------------------------------------
% Capítulo 3 – Desarrollo
%----------------------------------------------------------

%----------------------------------------------------------
\section{Base de datos}
%----------------------------------------------------------

\begin{large}

Para esta plataforma, la base de datos se implementó íntegramente en Firestore, aprovechando su modelo NoSQL en tiempo real y su escalabilidad automática. A continuación se describen los pasos clave:

\end{large}

\subsection{Configuración inicial en Firebase}

\begin{large}

En primer lugar, se creó un proyecto en la consola de Firebase y se habilitaron los servicios de Firestore y Authentication. Dentro de Firestore, se generó la colección raíz \textit{businesses}, donde cada documento tiene un identificador único (\textit{businessId}). De forma automática, Firestore asigna una referencia a cada colección y subcolección cuando se insertan documentos por primera vez desde los clientes.

Para conectar la aplicación iOS, se descargó el archivo \textit{GoogleService-Info.plist} desde la consola de Firebase y se añadió al directorio principal del proyecto Xcode. En el caso del portal web, se obtuvo el objeto de configuración (API key, project ID, etc.), se guardó en un archivo \textit{.env} y se cargó desde un archivo \textit{config.ts} bajo \textit{/src/firebase}.

\end{large}

\subsection{Reglas de seguridad de Firestore}

\begin{large}

Para garantizar que solo los usuarios autorizados accedieran a la información, se definieron reglas en el panel de Firestore. Un extracto de las reglas más relevantes es:

\begin{lstlisting}[language={}, caption={Reglas de seguridad de Firestore}]
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Raíz de negocios: controlamos creación/lectura/actualización/borrado a nivel de negocio
    match /businesses/{businessId} {
      // Cualquiera autenticado puede leer la información de un negocio
      allow read: if request.auth != null;
      // Cualquiera autenticado puede crear un nuevo negocio
      allow create: if request.auth != null;
      // Solo un admin (claim role == "admin") puede modificar o borrar un negocio
      allow update, delete: if request.auth.token.role == 'admin';
      
      // Subcolección de empleados: solo admins pueden gestionar empleados
      match /employees/{employeeId} {
        allow read: if request.auth != null;
        allow create, update, delete: if request.auth.token.role == 'admin';
      }
      
      // Subcolección de clientes: 
      //   - cualquiera autenticado ve datos de clientes
      //   - un admin o el propio cliente (uid == userClientId) puede crear/editar/borrar
      match /clients/{clientId} {
        allow read: if request.auth != null;
        allow create: if request.auth.token.role == 'admin';
        allow update, delete: if request.auth.token.role == 'admin'
                              || request.auth.uid == resource.data.userClientId;
      }
      
      // Subcolección de facturas:
      //   - cualquiera autenticado puede leer
      //   - crear: admin o empleado que firma la factura (employeeId en request.resource.data)
      //   - actualizar: admin o empleado que creó la factura (employeeId en el dato existente)
      //   - borrar: solo admin
      match /invoices/{invoiceId} {
        allow read: if request.auth != null;
        allow create: if request.auth.token.role == 'admin'
                      || request.auth.uid == request.resource.data.employeeId;
        allow update: if request.auth.token.role == 'admin'
                      || request.auth.uid == resource.data.employeeId;
        allow delete: if request.auth.token.role == 'admin';
        
        // Dentro de cada factura, la subcolección de líneas de producto:
        //   - cualquiera autenticado puede leer
        //   - solo el admin puede escribir/borrar
        match /productsStack/{productStackId} {
          allow read: if request.auth != null;
          allow create, update, delete: if request.auth.token.role == 'admin';
        }
      }
      
      // Subcolección de productos: 
      //   - cualquiera autenticado puede leer
      //   - solo admin puede escribir/borrar
      match /products/{productId} {
        allow read: if request.auth != null;
        allow create, update, delete: if request.auth.token.role == 'admin';
      }
    }
    
  }
}
\end{lstlisting}

Con estas reglas, solo el administrador (rol \textit{admin}) puede crear o eliminar facturas y productos, y cada empleado (rol \textit{employee}) puede crear o actualizar facturas que él mismo genere. Los clientes solo acceden a sus propios documentos, y todas las operaciones requieren un usuario autenticado (\textit{request.auth != null}), lo que cumple con los requisitos de seguridad y protección de datos.

\end{large}

%----------------------------------------------------------
\section{Implementación iOS}
%----------------------------------------------------------

\begin{large}

En esta sección profundizamos en la aplicación iOS, donde se dedicaron la mayoría de las horas de desarrollo. Partimos desde cero, aprendiendo Swift y SwiftUI, y construimos la app siguiendo el patrón MVVM para separar responsabilidades y lograr un código más mantenible.

\end{large}

\subsection{Configuración del proyecto y conexión a Firebase}

\begin{large}

Para iniciar el proyecto, se utilizó Xcode 16.3 con la plantilla de SwiftUI. Los pasos fueron:

\begin{enumerate}
  \item En Xcode, crear un nuevo proyecto seleccionando \emph{App} y, como lenguaje, \textbf{Swift} con interfaz \textbf{SwiftUI}.
  \item Descargar \textit{GoogleService-Info.plist} desde la consola de Firebase y arrastrarlo al grupo raíz del proyecto en Xcode. Asegurarse de marcar la opción de agregarlo a todos los targets.
  \item Instalar el paquete oficial de Firebase mediante Swift Package Manager (\emph{File → Add Packages…}), usando la URL \url{https://github.com/firebase/firebase-ios-sdk.git}.
  \item En el archivo \textit{QuickBillApp.swift}, inicializar Firebase antes de cargar la escena principal:
    \begin{lstlisting}[language={swift}, caption={Inicialización de Firebase en QuickBillApp.swift}]
    import SwiftUI
    import FirebaseCore
    
    @main
    struct QuickBillApp: App {
        @StateObject private var auth = AuthViewModel()
        @AppStorage("appLanguage") private var appLanguage: String = AppLanguage.english.rawValue
        
        init() {
            FirebaseApp.configure()
        }
        
        var body: some Scene {
            WindowGroup {
                if auth.isSignedIn {
                    MainTabView()
                } else {
                    StartView()
                }
            }
            .environmentObject(auth)
            .environment(\.locale, Locale(identifier: appLanguage))
        }
    }
    \end{lstlisting}
  \item Configurar en la consola de Firebase el dominio de la app, activando Authentication con correo/contraseña.
\end{enumerate}

Con estos pasos, la aplicación iOS ya está conectada a Firebase y lista para consumir Firestore y Authentication.

\end{large}

\subsection{Arquitectura MVVM}

\begin{large}

La aplicación iOS se organiza siguiendo el patrón \textit{Model–View–ViewModel} (MVVM). En la Figura~\ref{fig:models_folder} se muestra la distribución real de carpetas dentro de Xcode, enfocándose en la carpeta de los modelos:

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{Ilustraciones/ios_models_folder.png}
\caption{Estructura de la carpeta \textit{Models} en Xcode}
\label{fig:models_folder}
\end{figure}

A continuación se describe brevemente el propósito de cada grupo.

\textit{Models} agrupa todas las entidades que reflejan los documentos de Firestore. Cada subcarpeta contiene un único fichero con la estructura correspondiente:
\begin{itemize}
  \item \textbf{Client/Client.swift}: define la estructura \textit{Client} con campos básicos de la empresa o persona a facturar.
  \item \textbf{Employee/Employee.swift}: representa a cada empleado que accede a la app. Incluye su \textit{userId} (Firebase Auth), nombre, email, teléfono y rol.
  \item \textbf{Invoice}:
    \begin{itemize}
      \item \textit{Invoice.swift}: entidad principal con fechas, importes y referencias a cliente y empleado.
      \item \textit{InvoiceLineItem.swift}: describe cada línea de producto/servicio dentro de una factura.
      \item \textit{InvoiceStatus.swift}: \textit{enum} con los estados \textit{paid}, \textit{pending} y \textit{overdue}.
    \end{itemize}
  \item \textbf{Product}:
    \begin{itemize}
      \item \textit{Product.swift}: catálogo de productos con descripción y precio unitario.
      \item \textit{ProductStack.swift}: colección de productos que se añaden a una factura.
    \end{itemize}
  \item \textit{TabItem.swift}: enumeración con los tabs de navegación de la app.
\end{itemize}

\textit{Services} agrupa la lógica que no depende de la UI pero tampoco encaja como modelo puro:
\begin{itemize}
  \item \textit{AuthService.swift}: envoltorio sencillo sobre Firebase Auth con la finalidad de persistir la sesión de los usuarios en la aplicación.
  \item \textit{InvoicePDFBuilder.swift}: genera el PDF de una factura usando UIGraphicsPDFRenderer; recibe una instancia \textit{Invoice} y devuelve la URL local del fichero.
  \item \textit{InvoiceStatusService.swift}: actualiza el estado de una factura (\textit{paid}, \textit{pending}, \textit{overdue}) según \textit{issuedAt}, \textit{dueDate} y el \textit{status} almacenado.
\end{itemize}

\textit{Utilities} contiene código de soporte reutilizable. Actualmente sólo incluye \textit{AppLanguage.swift}, una enumeración para cambiar el idioma de la interfaz mediante la propiedad \textit{@AppStorage('appLanguage')}.

\textit{ViewModels} se divide en subcarpetas por dominio de negocio:
\begin{itemize}
  \item \textbf{Authentication}: gestiona el inicio de sesión, registro y la opción de 'ovidé mi contraseña'.
  \item \textbf{Clients}: gestión de listado, creación, borrado y edición de clientes.
  \item \textbf{Invoice}: \textit{InvoiceListViewModel.swift}, \textit{InvoiceDetailViewModel.swift} y \textit{AddInvoiceViewModel.swift} para listar, mostrar los detalles y crear nuevas faturas.
  \item \textbf{Products}: ViewModel para el catálogo de productos.
  \item \textbf{Settings}: controla las preferencias de la app.
  \item Además, en la raíz de la carpeta está \textit{AuthViewModel.swift}, que mantiene el estado global de autenticación y se inyecta como \textit{EnvironmentObject}.
\end{itemize}

\textit{Views} organiza las pantallas SwiftUI con la misma lógica de dominios:
\begin{itemize}
  \item \textbf{Authentication}: vistas de inicio de sesión y registro.
  \item \textbf{Clients}: lista de clientes y formulario de creación y edición.
  \item \textbf{Home}: vista inicial tras iniciar sesión (dashboard con todas las facturas).
  \item \textbf{Invoice}: formulario de creación y detalles de las facturas.
  \item \textbf{Products}: listado y formulario de productos.
  \item \textbf{Settings}: ajustes de idioma y cuenta.
  \item \textit{MainTabView.swift}: barra de pestañas inferior que enlaza \textit{Home}, \textit{Products}, \textit{Invoice}, \textit{Clients}, y \textit{Settings}.
  \item \textit{StartView.swift}: pantalla que decide si mostrar la vista de autenticación o el \textit{MainTabView} según el estado de \textit{AuthViewModel}.
\end{itemize}

Esta distribución favorece la separación de responsabilidades, donde los 
ViewModels actúan como enlace entre modelos y vistas, y cada conjunto de vistas se mantiene cohesionado dentro de su propio dominio y los modelos definen la estructura de los datos que se manejan.

\end{large}

\subsection{Generación de PDF}

\begin{large}

En el diseño original se consideró usar Cloud Functions para generar el PDF, pero para evitar costes adicionales se implementó en la app iOS, creando un servicio dedicado:

\begin{lstlisting}[language={swift}, caption={Servicio para generar PDF de facturas}]
import UIKit
import PDFKit

struct InvoicePDFBuilder {
    
    /// Devuelve la URL del PDF generado en el directorio *Documents*
    static func createPDF(for invoice: Invoice,
                          businessName: String,
                          clientName: String,
                          products: [ProductStack],
                          productNames: [String: String]) throws -> URL {
        
        // 1) Canvas A4
        let pdfMetaData = [
            kCGPDFContextCreator: "QuickBill",
            kCGPDFContextAuthor:  "QuickBill"
        ]
        let format = UIGraphicsPDFRendererFormat()
        format.documentInfo = pdfMetaData as [String: Any]
        
        let pageRect = CGRect(x: 0, y: 0, width: 595, height: 842) // A4 @72 dpi
        let renderer = UIGraphicsPDFRenderer(bounds: pageRect, format: format)
        
        let data = renderer.pdfData { ctx in
            ctx.beginPage()
            drawInvoice(invoice,
                        businessName: businessName,
                        clientName: clientName,
                        products: products,
                        productNames: productNames,
                        in: pageRect)
        }
        
        // 2) Guardar en Documents/Invoice-<id>.pdf
        let docs = FileManager.default.urls(for: .documentDirectory,
                                            in: .userDomainMask)[0]
        let url = docs.appendingPathComponent("Invoice-\(invoice.id).pdf")
        try data.write(to: url, options: .atomic)
        return url
    }
    
    // MARK: - Drawing helpers
    private static func drawInvoice(_ inv: Invoice,
                                    businessName: String,
                                    clientName: String,
                                    products: [ProductStack],
                                    productNames: [String: String],
                                    in rect: CGRect) {
        // Fuentes
        let titleFont   = UIFont.boldSystemFont(ofSize: 24)
        let labelFont   = UIFont.systemFont(ofSize: 12)
        let textFont    = UIFont.systemFont(ofSize: 12)
        let boldFont    = UIFont.boldSystemFont(ofSize: 12)
        
        var y: CGFloat = 36
        
        // Title
        "INVOICE".draw(at: CGPoint(x: rect.midX-40, y: y),
                       withAttributes: [.font: titleFont])
        y += 40
        
        // Company & Client blocks
        func drawBlock(label: String, lines: [String]) {
            label.uppercased().draw(at: CGPoint(x: 36, y: y),
                                    withAttributes: [.font: boldFont])
            y += 14
            for line in lines {
                line.draw(at: CGPoint(x: 42, y: y),
                          withAttributes: [.font: textFont])
                y += 14
            }
            y += 10
        }
        
        drawBlock(label: "Your company",
                  lines: [businessName])
        drawBlock(label: "Bill to",
                  lines: [clientName])
        
        // Invoice meta
        "Invoice #\(inv.id)".draw(at: CGPoint(x: 400, y: 80),
                                  withAttributes: [.font: boldFont])
        "Issued: \(date(inv.issuedAt))".draw(at: CGPoint(x: 400, y: 94),
                                             withAttributes: [.font: labelFont])
        "Due:    \(date(inv.dueDate))".draw(at: CGPoint(x: 400, y: 108),
                                            withAttributes: [.font: labelFont])
        
        y = max(y, 140)
        // Table header
        let colX: [CGFloat] = [36, 250, 330, 420, 500]
        ["Description","Supply","Qty","Unit","Amount"].enumerated().forEach { idx, txt in
            txt.draw(at: CGPoint(x: colX[idx], y: y),
                     withAttributes: [.font: boldFont])
        }
        y += 16
        UIColor.black.setStroke()
        UIBezierPath(rect: CGRect(x: 36, y: y, width: 524, height: 1)).fill()
        y += 6
        
        // Table rows
        products.forEach { p in
            let description = productNames[p.productId] ?? p.productId
            let total = String(format: "%.2f", p.amount)
            let unit  = String(format: "%.2f", p.amount / Double(p.quantity))
            let cols = [
                description,
                date(p.supplyDate),
                "\(p.quantity)",
                unit,
                total
            ]
            for (i, txt) in cols.enumerated() {
                txt.draw(at: CGPoint(x: colX[i], y: y),
                         withAttributes: [.font: textFont])
            }
            y += 14
        }
        
        // Subtotals
        y += 10
        func amountRow(_ label: String, _ value: Double, bold: Bool = false) {
            let attr: [NSAttributedString.Key: Any] = [.font: bold ? boldFont : textFont]
            label.draw(at: CGPoint(x: 400, y: y), withAttributes: attr)
            let val = String(format: "%.2f %@", value, inv.currency)
            val.draw(at: CGPoint(x: 500 - (val as NSString).size(withAttributes: attr).width, y: y),
                     withAttributes: attr)
            y += 14
        }
        amountRow("Subtotal",  inv.subtotal)
        amountRow("Tax",       inv.taxTotal)
        amountRow("Discounts", inv.discounts)
        UIBezierPath(rect: CGRect(x: 400, y: y, width: 160, height: 1)).fill()
        y += 4
        amountRow("TOTAL",     inv.totalAmount, bold: true)
    }
    
    private static func date(_ d: Date) -> String {
        let df = DateFormatter()
        df.dateStyle = .short
        return df.string(from: d)
    }
}
\end{lstlisting}

Para la numeración, se utilizó el identificador único que Firestore asigna al documento. Así, cada factura ya cuenta con un número único sin necesidad de mantener un contador manual.

\end{large}

\subsection{Autenticación y permisos}

\begin{large}

La app utiliza Firebase Authentication con correo y contraseña. En la pantalla de inicio de sesión:

\begin{verbatim}
import SwiftUI
import FirebaseAuth

struct LoginView: View {
    @State private var email: String = ""
    @State private var password: String = ""
    @State private var errorMessage: String?

    var body: some View {
        VStack(spacing: 16) {
            TextField("Correo electrónico", text: $email)
                .autocapitalization(.none)
                .keyboardType(.emailAddress)
                .padding()
                .background(Color(.secondarySystemBackground))
                .cornerRadius(8)
            SecureField("Contraseña", text: $password)
                .padding()
                .background(Color(.secondarySystemBackground))
                .cornerRadius(8)
            if let error = errorMessage {
                Text(error)
                    .foregroundColor(.red)
            }
            Button(action: signIn) {
                Text("Iniciar sesión")
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(Color.blue)
                    .foregroundColor(.white)
                    .cornerRadius(8)
            }
        }
        .padding()
    }

    func signIn() {
        Auth.auth().signIn(withEmail: email, password: password) { result, error in
            if let error = error {
                self.errorMessage = error.localizedDescription
            } else {
                // Guardar uid en AppStorage o pasar a vista principal
                // ...
            }
        }
    }
}
\end{verbatim}

Una vez autenticado, el \textit{currentUser.uid} se utiliza en cada consulta para filtrar facturas del empleado correspondiente:

\begin{verbatim}
db.collection("businesses")
  .document(businessId)
  .collection("invoices")
  .whereField("employeeId", isEqualTo: Auth.auth().currentUser?.uid ?? "")
  .getDocuments { snapshot, error in
    // ...
}
\end{verbatim}

\end{large}

\subsection{UI/UX y pruebas en simulador}

\begin{large}

Para verificar que todo funciona, se realizaron pruebas manuales en el simulador de iOS:

\begin{itemize}
  \item Crear una nueva factura: abrir \textit{InvoiceFormView}, rellenar campos, pulsar “Guardar” y comprobar que aparece en \textit{InvoiceListView}.
  \item Editar estado de factura: marcar una factura pendiente como “Paid” y verificar que cambia su color (verde) en la lista.
  \item Generar PDF: pulsar “Generar PDF” en \textit{InvoiceDetailView} y verificar que se guarda en la carpeta \emph{Documents} del simulador.
  \item Inicio de sesión: probar con credenciales correctas e incorrectas para validar la lógica de \textit{Auth}.
\end{itemize}

A continuación se muestran algunas capturas de pantalla (omitidas aquí) que ilustran estos flujos.

\end{large}

%----------------------------------------------------------
\section{Implementación web}
%----------------------------------------------------------

\begin{large}

La parte web, aunque más ligera, ofrece tres funcionalidades clave: gráfica de pagos mensuales, listado de morosos y tabla con todas las facturas. A continuación se describe su estructura y lógica:

\end{large}

\subsection{Estructura general del proyecto}

\begin{large}

El repositorio para el portal web sigue la convención estándar de Astro:
\begin{itemize}
  \item \textit{/src/pages}:
    \begin{itemize}
      \item \textit{index.astro}: página principal que importa los tres componentes.
      \item \textit{invoices.astro}: gestión de todas las facturas (tabla).
      \item \textit{overdue.astro}: listado de clientes morosos.
      \item \textit{chart.astro}: componente independiente para la gráfica mensual.
    \end{itemize}
  \item \textit{/src/components}:
    \begin{itemize}
      \item \textit{MoneyChart.astro}: renderiza la gráfica de barras usando \emph{lightweight-charts}.
      \item \textit{OverdueList.astro}: muestra tarjetas con clientes morosos y sus importes.
      \item \textit{InvoiceTable.astro}: tabla con todas las facturas (ID, cliente, importe, estado, fecha).
    \end{itemize}
  \item \textit{/src/firebase}:
    \begin{itemize}
      \item \textit{firebase.ts}: inicializa Firebase con la configuración y exporta instancias de \textit{firestore} y \textit{auth}.
      \item \textit{invoiceService.ts}: funciones para leer y escribir facturas en Firestore.
    \end{itemize}
  \item \textit{/src/styles}:
    \begin{itemize}
      \item \textit{globals.css}: importa y personaliza TailwindCSS.
      \item \textit{variables.css}: define paletas de color y tipografías.
    \end{itemize}
\end{itemize}

\end{large}

\subsection{Carga de datos y renderizado}

\begin{large}

Para obtener las facturas del negocio, \textit{invoiceService.ts} expone:

\begin{verbatim}
import { firestore } from "./firebase";

export async function getInvoices(businessId) {
  const snapshot = await firestore
    .collection(`businesses/${businessId}/invoices`)
    .orderBy("issuedAt", "desc")
    .get();
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}
\end{verbatim}

En \textit{InvoiceTable.astro} se utiliza:

\begin{verbatim}
---
import { getInvoices } from "../firebase/invoiceService";
const businessId = Astro.site.businessId;
const invoices = await getInvoices(businessId);
---
<table class="min-w-full bg-white">
  <thead>
    <tr>
      <th class="px-4 py-2">ID</th>
      <th class="px-4 py-2">Cliente</th>
      <th class="px-4 py-2">Importe</th>
      <th class="px-4 py-2">Estado</th>
      <th class="px-4 py-2">Fecha</th>
    </tr>
  </thead>
  <tbody class="text-center">
    {invoices.map(inv => (
      <tr class="border-t">
        <td class="px-4 py-2">{inv.id}</td>
        <td class="px-4 py-2">{inv.clientName}</td>
        <td class="px-4 py-2">{inv.totalAmount.toFixed(2)}</td>
        <td class="px-4 py-2">{inv.status}</td>
        <td class="px-4 py-2">{new Date(inv.issuedAt).toLocaleDateString()}</td>
      </tr>
    ))}
  </tbody>
</table>
\end{verbatim}

Para el listado de morosos, \textit{OverdueList.astro} filtra facturas cuyo estado sea “Pending” u “Overdue” y agrupa por cliente.

En \textit{MoneyChart.astro}, se transforma el array \textit{invoices} en dos series (pagos y pendientes) para la librería de gráficas:

\begin{verbatim}
---
import { createChart, HistogramSeries } from "https://cdn.jsdelivr.net/npm/lightweight-charts@5.0.7/+esm";

const invoiceData = await getInvoices(businessId);

// Agregar lógica para agrupar por mes y separar pagos/pendientes
const monthly = {};
invoiceData.forEach(inv => {
  const [year, month] = new Date(inv.issuedAt).toISOString().split("T")[0].split("-");
  const key = `${year}-${month}`;
  if (!monthly[key]) monthly[key] = { paid: 0, pending: 0 };
  if (inv.status === "Paid") {
    monthly[key].paid += inv.totalAmount;
  } else {
    monthly[key].pending += inv.totalAmount;
  }
});

const pendingData = [];
const paidData = [];
const ms12h = 12 * 60 * 60 * 1000;
Object.keys(monthly).sort().forEach(key => {
  const [yy, mm] = key.split("-");
  const base = new Date(`${yy}-${mm}-01T00:00:00Z`).getTime() / 1000;
  pendingData.push({ time: base, value: monthly[key].pending, color: "#facc15" });
  paidData.push({ time: base + ms12h, value: monthly[key].paid, color: "#16a34a" });
});

const container = document.getElementById("moneyChart");
const chart = createChart(container, {
  layout: { background: { color: "white" }, textColor: "#374151" },
  height: 250,
  timeScale: { tickMarkFormatter: time => new Date(time * 1000).toLocaleString("default", { month: "short" }) }
});
const pendSeries = chart.addSeries(HistogramSeries, { color: "#facc15" });
const paySeries = chart.addSeries(HistogramSeries, { color: "#16a34a" });
pendSeries.setData(pendingData);
paySeries.setData(paidData);
chart.timeScale().fitContent();
---
<div id="moneyChart" class="w-full h-64"></div>
\end{verbatim}

\end{large}

\subsection{Estilos y responsive}

\begin{large}

Para la tabla de facturas y la lista de morosos, se usaron clases de TailwindCSS:

\begin{itemize}
  \item Tablas: \textit{class="min-w-full bg-white"}, encabezados con \textit{px-4 py-2 text-left font-medium}, filas con \textit{border-t text-center}.
  \item Tarjetas de morosos: \textit{class="bg-white shadow rounded p-4 hover:shadow-lg grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4"}.
  \item Gráfica: contenedor con \textit{class="w-full h-64"} para acomodar el lienzo de \emph{lightweight-charts}.
\end{itemize}

La configuración responsive se logra con clases como \textit{grid-cols-1 md:grid-cols-2 lg:grid-cols-3} y utilidades de Tailwind para márgenes y paddings en distintos puntos de ruptura.

\end{large}

\subsection{Despliegue del portal en Vercel}

\begin{large}
	
El portal web se despliega en Vercel siguiendo el flujo de integración continua:

\begin{enumerate}
  \item Cada vez que se hace \emph{push} a la rama \textit{main}, Vercel detecta el cambio y ejecuta el comando \textit{npm run build}.
  \item Una vez compilado, Vercel optimiza los activos estáticos y publica el sitio en una URL de producción.
  \item Se configuró un dominio personalizado y se activaron los certificados TLS automáticos.
\end{enumerate}

A continuación se muestra una captura del panel de Vercel donde se observa el estado del último despliegue y la URL asignada (omitida en este texto).

\end{large}